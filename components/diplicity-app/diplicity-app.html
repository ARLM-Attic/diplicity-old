<link rel="import" href="/bower_components/core-scaffold/core-scaffold.html">
<link rel="import" href="/bower_components/core-header-panel/core-header-panel.html">
<link rel="import" href="/bower_components/core-toolbar/core-toolbar.html">
<link rel="import" href="/bower_components/core-animated-pages/core-animated-pages.html">
<link rel="import" href="/bower_components/core-menu/core-menu.html">
<link rel="import" href="/bower_components/core-animated-pages/core-animated-pages.html">
<link rel="import" href="/bower_components/core-item/core-item.html">
<link rel="import" href="/bower_components/paper-tabs/paper-tabs.html">
<link rel="import" href="/bower_components/core-animated-pages/transitions/cross-fade.html">
<link rel="import" href="/bower_components/more-routing/more-routing.html">
<link rel="import" href="/components/create-game/create-game.html">
<link rel="import" href="/components/my-games/my-games.html">
<link rel="import" href="/components/other-games/other-games.html">

<more-routing-config driver="path"></more-routing-config>
<more-route name="my-games" path="/games/mine">
  <more-route name="my-running-games" path="/running"></more-route>
  <more-route name="my-forming-games" path="/forming"></more-route>
  <more-route name="my-finished-games" path="/finished"></more-route>
</more-route>
<more-route name="other-games" path="/games/other">
  <more-route name="other-open-games" path="/open"></more-route>
  <more-route name="other-closed-games" path="/closed"></more-route>
  <more-route name="other-finished-games" path="/finished"></more-route>
</more-route>
<more-route name="create-game" path="/games/create"></more-route>

<polymer-element name="diplicity-app">
  <template>
	  <style>
			core-toolbar a {
				text-decoration: none;
				font-size: x-large;
			}
		</style>
    <core-scaffold flex>
		  <core-header-panel navigation flex mode="seamed">
			  <core-toolbar>
				  <div flex>
						<a href="/">
							diplicity
						</a>
				  </div>
		    </core-toolbar>
				<core-menu>
					<template if="{{ user.Id }}">
						<a href="/logout">
							<core-item icon="lock-outline" label="Logout"></core-item>
						</a>
						<core-item icon="settings" label="{{ user.Email }}"></core-item>
					</template>
					<template if="{{ !user.Id }}">
					  <a href="{{ loginUrl }}">
				      <core-item icon="lock-open" label="Login"></core-item>
						</a>
					</template>
				</core-menu>
			</core-header-panel>
	    <div tool flex>
				<template if="{{ user.Id }}">
				  <paper-tabs valueattr="route" selected="{{ topTab }}">
					  <paper-tab route="/">My games</paper-tab>
    			  <paper-tab route="/games/other">Other games</paper-tab>
    			  <paper-tab route="/games/create">Create game</paper-tab>
    			</paper-tabs>
				</template>
				<template if="{{ !user.Id }}">
				  <paper-tabs>
						<paper-tab>Games</paper-tab>
					</paper-tabs>
				</template>
      </div>
			<div flex>
				<template if="{{ user.Id }}">
  				<core-animated-pages valueattr="route" selected="{{ topTab }}" transitions="cross-fade">
    			  <div route="/" cross-fade>
							<my-games user="{{ user }}" leaver="{{ gameLeaver() }}" joiner="{{ gameJoiner() }}" subscriber="{{ subscriber() }}" tab="{{ bottomTab }}"></my-games>
    				</div>
    				<div route="/games/other" cross-fade>
							<other-games user="{{ user }}" leaver="{{ gameLeaver() }}" joiner="{{ gameJoiner() }}" subscriber="{{ subscriber() }}" tab="{{ bottomTab }}"></other-games>
    				</div>
    				<div route="/games/create" cross-fade>
    					<create-game creator="{{ gameCreator() }}"></create-game>
    				</div>
    			</core-animated-pages>
				</template>
				<template if="{{ !user.Id }}">
				  <other-games user="{{ user }}" leaver="{{ gameLeaver() }}" joiner="{{ gameJoiner() }}" subscriber="{{ subscriber() }}"></other-games>
				</template>
			</div>
		</core-scaffold>
	</template>
	<script>
		Polymer({
			subscriber: function() {
				return this;
			},
			connectWebSocket: function() {
				var socketUrl = "";
				if (window.location.protocol == 'http:') {
					socketUrl = "ws://";
				} else if (window.location.protocol == 'https:') {
					socketUrl = "wss://";
				} else {
				  throw "Unknown protocol " + window.location.protocol;
				}
				socketUrl += window.location.host + "/ws";
				if (this.token != null) {
					socketUrl += "?token=" + this.token.Encoded;
				}
				if (this.socket != null) {
					this.connected = false;
					this.socket.close();
				}
				this.socket = new WebSocket(socketUrl);
				this.socket.onerror = function(options) {
					this.connected = false;
					console.log('error', options);
					this.fetchToken();
				};
				this.socket.onmessage = function(options) {
					var message = JSON.parse(options.data);
					console.log('Message', message);
					var subs = this.subscriptions[message.Object.URI];
					if (subs != null) {
						for (var i = 0; i < subs.length; i++) {
							if (message.Type == 'Fetch') {
							  subs[i].set(message.Object.Data);
							} else {
							  var old = subs[i].get();
								if (old.constructor === Array) {
								  switch (message.Type) {
									case 'Create':
                    subs[i].set(old.concat(message.Object.Data));
										break;
									case 'Update':
									  var updated = {};
										_.each(message.Object.Data, function(el) {
											updated[el.Id] = el;
										});
									  old = _.collect(old, function(el) {
											var found = updated[el.Id];
											if (found == null) {
												return el;
											} else {
											  return found;
											}
									  });
									  subs[i].set(old);
										break;
									case 'Delete':
									  var deleted = {};
										_.each(message.Object.Data, function(el) {
											deleted[el.Id] = el;
										});
									  old = _.reject(old, function(el) {
											return deleted[el.Id] != null;
										});
										subs[i].set(old);
										break;
									}
								} else {
								  switch (message.Type) {
									case 'Create':
									  console.log('Message was a create on a non Array type subscription. Very confusing.');
									  subs[i].set(message.Object.Data);
										break;
									case 'Update':
									  subs[i].set(message.Object.Data);
										break;
									case 'Delete':
									  old = $.extend({}, old);
									  old._deleted = true;
										subs[i].set(old);
										break;
									}
								}
							}
						}
					}
				}.bind(this);
				this.socket.onopen = function(options) {
					this.connected = true;
					for (var uri in this.subscriptions) {
						var cb = this.subscriptions[uri];
						this.socket.send(JSON.stringify({
							Type: "Subscribe", 
							Object: {
								URI: uri,
						  },
						}));
					}
				}.bind(this);
				this.socket.onclose = function(options) {
					this.connected = false;
					console.log('close', options);
				}.bind(this);
			},
			fetchToken: function() {
        $.ajax('/token', {
					success: function(data) {
						this.token = data;
						this.connectWebSocket();
					}.bind(this),
				});
			},
			subscribe: function(uri, newSub) {
				var alreadySubscribed = true;
				var subs = this.subscriptions[uri];
				if (subs == null || subs.length == 0) {
					subs = [newSub];
					alreadySubscribed = false;
				} else {
				  subs = _.reject(subs, function(sub) {
						return sub == newSub;
					}).concat([newSub]);
				}
				this.subscriptions[uri] = subs;
				if (!alreadySubscribed && this.connected) {
					this.socket.send(JSON.stringify({
						Type: "Subscribe",
						Object: {
							URI: uri,
						},
					}));
				}
			},
			subscriptions: {},
			unsubscribe: function(uri, toRemove) {
				var subs = this.subscriptions[uri];
				if (subs != null) {
					subs = _.reject(this.subscriptions[uri], function(sub) {
						return sub == toRemove;
					});
					if (subs.length == 0 && this.connected) {
						this.socket.send(JSON.stringify({
							Type: "Unsubscribe",
							Object: {
								URI: uri,
							},
						}));
					}
					this.subscriptions[uri] = subs;
				}
			},
			gameLeaver: function() {
				return {
					leave: function(g) {
						this.socket.send(JSON.stringify({
							Type: "Delete",
							Object: {
								URI: "/games/" + g.Id,
							},
						}));
					}.bind(this),
				};
			},
			gameJoiner: function() {
				return {
					join: function(g) {
						this.socket.send(JSON.stringify({
							Type: "Update",
							Object: {
								URI: "/games/" + g.Id,
								Data: g,
							},
						}));
					}.bind(this),
				};
			},
			gameCreator: function() {
				return {
					create: function(g) {
						this.socket.send(JSON.stringify({
							Type: "Create",
							Object: {
								URI: "/games",
								Data: g,
							},
						}));
						MoreRouting.navigateTo('my-forming-games');
					}.bind(this),
				};
			},
			tabSelected: function(params) {
				console.log(params);
			},
			parseLocation: function() {
				console.log(this, 'parseLocation', window.location.pathname);
				if (window.location.pathname == '/') {
					this.topTab = '/';
					this.bottomTab = '/';
				} else if (window.location.pathname == '/games/create') {
				  this.topTab = window.location.pathname;
					this.bottomTab = window.location.pathname;
				} else if (window.location.pathname.indexOf('/games/mine') == 0) {
          this.topTab = '/';
					this.bottomTab = window.location.pathname;
					console.log('parseLocation found', window.location.pathname, this.topTab, this.bottomTab);
				} else if (window.location.pathname.indexOf('/games/other/') == 0) {
          this.topTab = '/games/other';
					this.bottomTab = window.location.pathname;
				}
			},
			topTabChanged: function(oldVal, newVal) {
				if (newVal != 0) {
					if (newVal == '/') {
						this.bottomTab = newVal;
					} else if (newVal == '/games/other') {
					  this.bottomTab = '/games/other/open';
					}
				}
			},
			bottomTabChanged: function(oldVal, newVal) {
				if (newVal != 0) {
					console.log('bottom tab pushing', newVal);
					window.history.pushState({ path: newVal }, newVal, newVal);
				}
			},
			ready: function() {
				this.socket = null;
				this.token = null;
        this.user = {};
				this.connected = false;
				this.loginUrl = window.location.protocol + "//" + window.location.host + "/login?return_to=" + encodeURIComponent(window.location.href);
				this.userSubscription = {
					get: function() {
						return this.user;
					}.bind(this),
					set: function(u) {
						this.user = u;
					}.bind(this),
				};
				this.subscribe("/user", this.userSubscription);
				this.fetchToken();
				$(window).on('popstate', this.parseLocation.bind(this));
				this.parseLocation();
			},
			detached: function() {
				this.unsubscribe('/user', this.userSubscription);
			},
		});
	</script>
</polymer-element>

