<link rel="import" href="/components/z-panel/z-panel.html">

<polymer-element name="game-list-element" attributes="game user">
  <template>
	  <style>
			paper-button.toggle {
				display: block;
				background: #CFD8DC;
				margin: 0.35em;
			}
			.toggle-title {
				text-transform: none !important;
			}
			table {
				border-collapse: collapse;
				width: 100%;
			}
			td {
				border: 1px solid #CFD8DC;
				padding: 0.35em;
			}
			paper-button::shadow .button-content {
				justify-content: flex-start !important;
			}
			.members-toggle {
				height: 1.25em;
			}
			.members-toggle::shadow .button-content {
				padding: 0.0em 0.57em;
			}
			.secret-flag {
				text-decoration: line-through;
			}
		</style>
		<paper-button class="toggle" on-click="{{ toggleOpened }}" raised>
		  <span class="toggle-title">
				<template if="{{ game.State != gameStates.created }}">
     			<template if="{{ me }}">
     			{{ me.Nation }}, {{ game.Phase.Season }} {{ game.Phase.Year }}, {{ game.Phase.Type }}, {{ deadlines }}
     			</template>
     			<template if="{{ !me }}">
     			{{ game.Phase.Season }} {{ game.Phase.Year }}, {{ game.Phase.Type }}, {{ deadlines }}
     			</template>
				</template>
				<template if="{{ game.State == gameStates.created }}">
				{{ game.Members.length }}/{{ variant.Nations.length }} members, {{ deadlines }}, {{ game.AllocationMethod }}
				</template>
			</span>
		</paper-button>
		<core-collapse opened="{{ opened }}">
		  <z-panel>
       	<paper-button class="toggle members-toggle" on-click="{{ toggleMembersOpened }}" raised>
       	  <span class="toggle-title">
						{{ game.Members.length }}/{{ variant.Nations.length }} members
       		</span>
       	</paper-button>
      	<core-collapse opened="{{ membersOpened }}">
      	  <z-panel>
					  <table>
							<template repeat="{{ member in game.Members }}">
     						<tr>
									<template if="{{ member.Nation }}">
									  <td>{{ member.Nation }}</td>
									</template>
									<template if="{{ member.User.Nickname && member.User.Email }}">
									  <td>{{ member.User.Nickname }} &lt;{{ member.User.Email }}&gt;</td>
									</template>
									<template if="{{ member.User.Nickname && !member.User.Email }}">
									  <td>{{ member.User.Nickname }}</td>
									</template>
									<template if="{{ !member.User.Nickname && member.User.Email }}">
									  <td>Anonymous &lt;{{ member.User.Email }}&gt;</td>
									</template>
									<template if="{{ !member.User.Nickname && !member.User.Email }}">
									  <td>Anonymous</td>
									</template>
     						</tr>
							</template>
						</table>
					</z-panel>
				</core-collapse>
			  <table>
			  	<tr>
						<td>Variant</td>
						<td>{{ capitalize(game.Variant) }}</td>
				  </tr>
			  	<tr>
						<td>Allocation method</td>
						<td>{{ capitalize(game.AllocationMethod) }}</td>
				  </tr>
			  	<tr>
						<td>Private</td>
						<td>{{ capitalize('' + game.Private) }}</td>
				  </tr>
			  	<tr>
						<td>Ranking</td>
						<td>{{ capitalize('' + game.Ranking) }}</td>
				  </tr>
					<template if="{{ notCommitting }}">
     		  	<tr>
     					<td>Not committing</td>
     					<td>{{ capitalize(notCommitting) }}</td>
     			  </tr>
					</template>
					<template if="{{ nmr }}">
			      <tr>
				    	<td>Not committing + NMR</td>
				    	<td>{{ capitalize(nmr) }}</td>
				    </tr>
					</template>
			  	<tr>
						<td>Before game</td>
						<td>{{ capitalize(beforeGame) }}</td>
				  </tr>
			  	<tr>
						<td>Movement</td>
						<td>{{ capitalize(movement) }}</td>
				  </tr>
			  	<tr>
						<td>Adjustment</td>
						<td>{{ capitalize(adjustment) }}</td>
				  </tr>
			  	<tr>
						<td>Retreat</td>
						<td>{{ capitalize(retreat) }}</td>
				  </tr>
			  	<tr>
						<td>After game</td>
						<td>{{ capitalize(afterGame) }}</td>
				  </tr>
				</table>
			</z-panel>
		</core-collapse>
	</template>
	<script>
		Polymer({
			toggleOpened: function() {
				this.opened = !this.opened;
			},
			toggleMembersOpened: function() {
				this.membersOpened = !this.membersOpened;
			},
			stringify: JSON.stringify,
			findMe: function(u, g) {
				if (u.Email == null) {
					return null;
				}
				return _.find(this.game.Members, function(member) {
					return member.User.Email == u.Email;
				}.bind(this));
			},
			findVariant: function(g) {
				return Variants[g.Variant];
			},
			gameStates: GameStates,
			timeInWords: function(m) {
				var hours = parseInt(m / 60);
				var minutesLeft = m - (hours * 60);
				if (minutesLeft == 0) {
					return '' + hours + 'h';
				} else {
				  return '' + hours + ':' + minutesLeft + 'h';
				}
			},
			displayDeadlines: function(g) {
				if (g.Deadlines.Movement == g.Deadlines.Adjustment && g.Deadlines.Adjustment == g.Deadlines.Retreat) {
				  return this.timeInWords(g.Deadlines.Movement);
				}
				if (g.Deadlines.Adjustment == g.Deadlines.Retreat) {
					return this.timeInWords(g.Deadlines.Movement) + '/' + this.timeInWords(g.Deadlines.Adjustment);
				}
				return this.timeInWords(g.Deadlines.Movement) + '/' + this.timeInWords(g.Deadlines.Retreat) + '/' + this.timeInWords(g.Deadlines.Adjustment);
			},
			displayConsequences: function(c) {
        var result = [];
				if (c & Consequences.ReliabilityHit == Consequences.ReliabilityHit) {
					result.push("reliability hit")
				}
				if (c & Consequences.NoWait == Consequences.NoWait) {
					result.push("no wait")
				}
				if (c & Consequences.Surrender == Consequences.Surrender) {
					result.push("surrender")
				}
				return result.join(", ");
			},
			conjoin: function(a) {
				if (a.length == 0) {
					return "";
				}
				if (a.length == 1) {
					return a[0];
				}
				return a.slice(0, a.length - 1).join(", ") + " and " + a[a.length - 1];
			},
			capitalize: function(s) {
				if (s.length == 0) {
					return "";
				}
				return s.substring(0,1).toUpperCase() + s.substring(1, s.length);
			},
			displayPhase: function(g, p) {
        var result = [];
				var deadline = g.Deadlines[p];
				if (deadline != null) {
					result.push(this.timeInWords(deadline));
				}
				var chats = [];
				if (g.ChatFlags[p] & ChatFlags.Private == ChatFlags.Private) {
					chats.push("private")
				}
				if (g.ChatFlags[p] & ChatFlags.Group == ChatFlags.Group) {
					chats.push("group")
				}
				if (g.ChatFlags[p] & ChatFlags.Conference == ChatFlags.Conference) {
					chats.push("conference")
				}
				if (chats.length > 0) {
					result.push(this.conjoin(chats) + " chat");
				}
				var generalPhase = "DuringGame";
				if (p == "BeforeGame" || p == "AfterGame") {
					generalPhase = p;
				}
				var secrets = [];
				if (g.SecretNation & SecretFlags[generalPhase] == SecretFlags[generalPhase]) {
					secrets.push("nation")
				}
				if (g.SecretNickname & SecretFlags[generalPhase] == SecretFlags[generalPhase]) {
					secrets.push("nickname")
				}
				if (g.SecretEmail & SecretFlags[generalPhase] == SecretFlags[generalPhase]) {
					secrets.push("email")
				}
				if (secrets.length > 0) {
					result.push("secret " + this.conjoin(secrets));
				}
				return result.join(", ");
			},
			computed: {
				me: 'findMe(user, game)',
				deadlines: 'displayDeadlines(game)',
				variant: 'findVariant(game)',
				notCommitting: 'displayConsequences(game.NonCommitConsequences)',
				nmr: 'displayConsequences(game.NMRConsequences)',
				beforeGame: 'displayPhase(game, "BeforeGame")',
				movement: 'displayPhase(game, "Movement")',
				adjustment: 'displayPhase(game, "Adjustment")',
				retreat: 'displayPhase(game, "Retreat")',
				afterGame: 'displayPhase(game, "AfterGame")',
			},
		});
	</script>
</polymer-element>



