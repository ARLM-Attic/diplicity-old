<link rel="import" href="/components/z-panel/z-panel.html">

<polymer-element name="game-list-element" attributes="game user">
  <template>
	  <style>
			paper-button.toggle {
				display: block;
				background: #CFD8DC;
				margin: 0.35em;
			}
			.toggle-title {
				text-transform: none !important;
			}
			table {
				border-collapse: collapse;
				width: 100%;
			}
			td {
				border: 1px solid #CFD8DC;
				padding: 0.35em;
			}
			paper-button::shadow .button-content {
				justify-content: flex-start !important;
			}
			.members-toggle {
				height: 1.25em;
			}
			.members-toggle::shadow .button-content {
				padding: 0.0em 0.57em;
			}
		</style>
		<paper-button class="toggle" on-click="{{ toggleOpened }}" raised>
		  <span class="toggle-title">
				<template if="{{ game.State != gameStates.created }}">
     			<template if="{{ me }}">
     			{{ me.Nation }}, {{ game.Phase.Season }} {{ game.Phase.Year }}, {{ game.Phase.Type }}, {{ deadlines }}
     			</template>
     			<template if="{{ !me }}">
     			{{ game.Phase.Season }} {{ game.Phase.Year }}, {{ game.Phase.Type }}, {{ deadlines }}
     			</template>
				</template>
				<template if="{{ game.State == gameStates.created }}">
				{{ game.Members.length }}/{{ variant.Nations.length }} members, {{ deadlines }}, {{ game.AllocationMethod }}
				</template>
			</span>
		</paper-button>
		<core-collapse opened="{{ opened }}">
		  <z-panel>
       	<paper-button class="toggle members-toggle" on-click="{{ toggleMembersOpened }}" raised>
       	  <span class="toggle-title">
						{{ game.Members.length }}/{{ variant.Nations.length }} members
       		</span>
       	</paper-button>
      	<core-collapse opened="{{ membersOpened }}">
      	  <z-panel>
					  Here be members
					</z-panel>
				</core-collapse>
			  <table>
			  	<tr>
						<td>Variant</td>
						<td>{{ game.Variant }}</td>
				  </tr>
			  	<tr>
						<td>Allocation method</td>
						<td>{{ game.AllocationMethod }}</td>
				  </tr>
			  	<tr>
						<td>Private</td>
						<td>{{ game.Private }}</td>
				  </tr>
			  	<tr>
						<td>Ranking</td>
						<td>{{ game.Ranking }}</td>
				  </tr>
			  	<tr>
						<td>Not committing</td>
						<td>{{ notCommitting }}</td>
				  </tr>
			  	<tr>
						<td>Not committing + NMR</td>
						<td>{{ nmr }}</td>
				  </tr>
			  	<tr>
						<td>Before game</td>
						<td>{{ beforeGame }}</td>
				  </tr>
			  	<tr>
						<td>Movement</td>
						<td>{{ movement }}</td>
				  </tr>
			  	<tr>
						<td>Adjustment</td>
						<td>{{ adjustment }}</td>
				  </tr>
			  	<tr>
						<td>Retreat</td>
						<td>{{ retreat }}</td>
				  </tr>
			  	<tr>
						<td>After game</td>
						<td>{{ afterGame }}</td>
				  </tr>
				</table>
			</z-panel>
		</core-collapse>
	</template>
	<script>
		Polymer({
			toggleOpened: function() {
				this.opened = !this.opened;
			},
			toggleMembersOpened: function() {
				this.membersOpened = !this.membersOpened;
			},
			stringify: JSON.stringify,
			findMe: function(u, g) {
				if (u.Email == null) {
					return null;
				}
				return _.find(this.game.Members, function(member) {
					return member.User.Email == u.Email;
				}.bind(this));
			},
			findVariant: function(g) {
				return Variants[g.Variant];
			},
			gameStates: GameStates,
			timeInWords: function(m) {
				var hours = parseInt(m / 60);
				var minutesLeft = m - (hours * 60);
				if (minutesLeft == 0) {
					return '' + hours + 'h';
				} else {
				  return '' + hours + ':' + minutesLeft + 'h';
				}
			},
			displayDeadlines: function(g) {
				if (g.Deadlines.Movement == g.Deadlines.Adjustment && g.Deadlines.Adjustment == g.Deadlines.Retreat) {
				  return this.timeInWords(g.Deadlines.Movement);
				}
				if (g.Deadlines.Adjustment == g.Deadlines.Retreat) {
					return this.timeInWords(g.Deadlines.Movement) + '/' + this.timeInWords(g.Deadlines.Adjustment);
				}
				return this.timeInWords(g.Deadlines.Movement) + '/' + this.timeInWords(g.Deadlines.Retreat) + '/' + this.timeInWords(g.Deadlines.Adjustment);
			},
			displayConsequences: function(c) {
        var result = [];
				if (c & Consequences.ReliabilityHit == Consequences.ReliabilityHit) {
					result.push("reliability hit")
				}
				if (c & Consequences.NoWait == Consequences.NoWait) {
					result.push("no wait")
				}
				if (c & Consequences.Surrender == Consequences.Surrender) {
					result.push("surrender")
				}
				return result.join(", ");
			},
			displayPhase: function(g, p) {
        var result = [];
				if (g.ChatFlags[p] & ChatFlags.Private == ChatFlags.Private) {
					result.push("private")
				}
				if (g.ChatFlags[p] & ChatFlags.Group == ChatFlags.Group) {
					result.push("group")
				}
				if (g.ChatFlags[p] & ChatFlags.Conference == ChatFlags.Conference) {
					result.push("conference")
				}
				var deadline = g.Deadlines[p];
				if (deadline != null) {
					result.push(this.timeInWords(deadline));
				}
				return result.join(", ");
			},
			computed: {
				me: 'findMe(user, game)',
				deadlines: 'displayDeadlines(game)',
				variant: 'findVariant(game)',
				notCommitting: 'displayConsequences(game.NonCommitConsequences)',
				nmr: 'displayConsequences(game.NMRConsequences)',
				beforeGame: 'displayPhase(game, "BeforeGame")',
				movement: 'displayPhase(game, "Movement")',
				adjustment: 'displayPhase(game, "Adjustment")',
				retreat: 'displayPhase(game, "Retreat")',
				afterGame: 'displayPhase(game, "AfterGame")',
			},
		});
	</script>
</polymer-element>



